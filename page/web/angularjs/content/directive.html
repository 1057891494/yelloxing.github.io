<article class='notebook content'>
    <section class='section'>
        <p class="block">
            <span class='warn'>
                温馨提示：这里介绍的是自定义指令涉及的内容，不是使用内置指令相关问题。
            </span>
        </p>
    </section>
    <section class='section'>
        <p class='block title-flag'>
            第一步：如何自定义指令。
        </p>
        <pre class='code'>angular.module('yelloxingApp', []).directive('uiDirective', function() {
        return {
            restrict:String,//标明该指令可以在模板中用于元素E、属性A、类C和注释M或组合
            priority:Number,//设置指令执行优先级，在某个DOM上优先级高的会先执行
            terminal:Boolean,
            template:String or Template Function,//就是设置模板，和下面的templateUrl属性二个只可以设置一个，目的一样
            templateUrl:String or Template Function,//除了字符串，这二个属性还可以设置函数，后面具体介绍
            replace:Boolean,//指令模板是否替换原来的元素
            transclude:Boolean,
            scope:Boolean or Object,
            controller:String or function(scope, element, attrs, transclude, otherInjectables) { ... },
            controllerAs:String,
            require:String or Array,
            //你需要知道link在每个实例都执行一遍，compile全程只会执行一遍
            link: function(scope, element, attrs,ctrl) { ... },
            compile:function(element, attrs, transclude) {
                //常用的就是compile的此处写执行一次的代码，或者在link方法里面写和dom有关的操作
                return {
                    pre: function(scope, element, attrs, ctrl) { ... },
                    post: function(scope, element, attrs, ctrl) { ... }
                }
                return function postLink(...) { ... }
            }
        };
    }); </pre>
        <p class="block">
            上面是大致的说明，后面来具体说明一些没有提及的细节和重要的相关知识。
        </p>
    </section>
    <section class="section">
        <p class="block title-flag">
            第二步：重要的相关知识
        </p>
        <p class="block little-flag">
            视图和model之间的数据格式化
        </p>
        <p class="block">
            类似过滤器的功能，有时候我们希望页面显示的是数据经过某种翻译后的样子，以便于约定，不过对于数据库也许简单的序号会更有益，因此你可能会需要在link中使用下面的方法来实现这个功能：
            <span class="list">
                1.ctrl.$formatters.unshift(function(input) {//model到view的数据格式化})；
            </span>
            <span class="list">
                2.ctrl.$parsers.unshift(function(input) {//view到model的数据格式化})。
            </span>
        </p>
        <p class="block">
            上面的$formatters和$parsers就是二个队列，视图到model和model到视图，会方便经过里面定义的方法的过滤，有点类似管道流，最后流到目的地。
            <span class="error">
                别忘了设置类似require: "?ngModel"这样的语句去查找控制器。
            </span>
        </p>
        <p class="block little-flag">
            几个零碎的方法
        </p>
        <p class="block">
            <span class="list">
                1.根据输入框是否合法来设置true或false：ctrl.$setValidity(errorType, boolean);//errorType表示错误类别，可以自定义
            </span>
            <span class="list">
                2.设置监听指定的一个model值，当然还有监听集合等方法：$scope.$watch(attrs['ngModel'], function(newValue, oldValue) {});
            </span>
            <span class="list">
                3.有时候在指令里面新添加的字符串需要被angularjs管理，就可以用下面的方法编译一下：$compile(newHtml)($scope)。
            </span>
        </p>
        <p class="block little-flag">
            视图和model数据同步问题
        </p>
        <p class="block">
            有时候在指令里面通过jquery修改了input的数据，不过angularjs并不会知道，这时候，你可以选择下面中的一个方法：
            <span class="list">
                1.触发输入框change改变，让Angularjs发现数据改变了，从而去调用$setViewValue(value),同步数据：$("input").trigger("change");
            </span>
            <span class="list">
                2.直接手动触发同步value到viewValue和modelValue中的行为：ctrl.$setViewValue($scope.info)。
            </span>
        </p>
    </section>
</article>
