<article class='notebook content'>
    <section class='section'>
        <p class="block">
            <span class="warn">
                注意：此为ECMAScript6新特性。
            </span>
        </p>
    </section>
    <section class='section'>
        <p class="block title-flag">
            第一步：基本使用
        </p>
        <p class="block">
            定义函数名称时带一个*的函数就是Generator函数，内部的yield语句是特色，该函数的使用可以用下面的几条概括一下：
            <span class="list">1.调用Generator函数并不会立刻return结果，而是在遇到第一个yield语句前停止下来，返回一个指针（姑且这样称呼）；</span>
            <span class="list">2.以后每次调用yield时候（具体看下面例子，直到遇到yield或return时停止继续执行），会返回yield数据，有点类似return；</span>
            <span class="list">3.返回的数据格式从下面的例子应该就明白了，没有yield或return语句会发生什么应该也明白了。</span>
        </p>
        <pre>function *firstYieldFun(){
        yield 'yello';
        yield 'xing';
        return 'name:';
    }
    var fun=firstYieldFun();
    console.log(fun.next());//{value: "yello", done: false}
    console.log(fun.next());//{value: "xing", done: false}
    console.log(fun.next());//{value: "name:", done: true}
    console.log(fun.next());//{value: undefined, done: true}
    console.log(fun.next());//{value: undefined, done: true}</pre>
        <p class="block">
            简单的说，Generator函数就是一个分段执行的函数，走走停停，yield用来切割代码成一段段的，next()方法用来启动执行下一段这个行为。
            <span class="warn">
                forEach方法的参数是一个普通函数，Generator函数不可以作为参数。
            </span>
        </p>
    </section>
    <section class='section'>
        <p class="block title-flag">
            第二步：重要的说明
        </p>
        <p class="block little-flag">
            yield特殊使用
        </p>
        <p class="block">
            除了上面的例子yield单独成为一个语句，其还可以用于表达式，函数参数和赋值表达式的右边等。
            <span class="warn">需要注意的是，yield要明确归属，用小括号包裹，小括号不是必须的，是在归属关系不明确的时候才是必须的，例如：console.log('My name is : '+(yield '心叶'))；</span>
        </p>
        <p class="block little-flag">
            next()方法带参数时
        </p>
        <p class="block">
            yield本身不会返回值，或者说是undefined，不过next()方法如果带参数情况就不一样了，此时就会返回yield带的参数，如下例子说明：
        </p>
        <pre>function* secondYieldFun() {
        console.log(yield '心叶');
    }
    var fun = secondYieldFun();
    console.log(fun.next()); //{value: "心叶", done: false}
    //这是参数
    console.log(fun.next('这是参数')); //{value: undefined, done: true}</pre>
    </section>
</article>
