<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset='utf-8'>
    <title>云笔记-遇见更好的你</title>
    <link rel="icon" href="../../../favicon.ico" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no,maximum-scale=1" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="format-detection" content="email=no" />
    <meta name="Keywords" content="云笔记-遇见更好的你" />
    <meta name="description" content="云笔记-遇见更好的你" />
    <meta name="author" content="心叶" />
    <link rel="apple-touch-icon" sizes="52x52" href="52icon.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="72icon.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="120icon.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="144icon.png" />
    <link rel="stylesheet" href="../../../style.css" class="style">
    <script src="../../../script.js"></script>
    <script>
        if (location.hostname == 'localhost' && location.hostname == '127.0.0.1') {
            document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')
        }
    </script>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-pub-7416565268644863",
        enable_page_level_ads: true
      });
    </script>
</head>

<body class='home'>
    <header>
        <div>
            <nav>
                云笔记-遇见更好的你
                <ul>
                    <li><a href="../../../pages/web.html">前端</a></li>
                    <li><a href="../../../pages/devLanguage.html">开发语言</a></li>
                    <li><a href="../../../pages/computer.html">计算机</a></li>
                    <li><a href="../../../pages/tool.html">工具</a></li>
                    <li><a href="../../../pages/other.html">其它</a></li>
                </ul>
                <div class='yelloxing' onclick="window.location.href='../../../stepbystep.html'">
                    <div>心叶
                        <div></div>
                    </div>
                </div>
                <a href="../../../opensource.html" class='opensource' target="_black">开源项目</a>
                <a href="javascript:void(0)" onclick='alert("非常抱歉，目前没有可以演示的特效！")' class='online'>在线演示</a>
                <div class='contact'>
                    联系我们
                    <div>
                        <a href="mailto:yelloxing@gmail.com?subject=意见反馈（云笔记-只为遇见更好的你）" class='gmail'>
                            邮箱
                        </a>
                        <a href="http://wpa.qq.com/msgrd?v=3&uin=1276327934&site=云笔记-遇见更好的你&menu=yes" class='qq' target="_blank">
                            QQ
                        </a>
                        <a href="https://github.com/yelloxing" class='github' target="_blank">
                            Github
                        </a>
                    </div>
                </div>
            </nav>
        </div>
    </header>
    <section id='book-content'>
        <nav>
            <div style='background-image:url("../../../image/nav/algorithm.png")'>
                算法设计与分析
            </div>
            <ul>
                <li>
                    <a href='RecursionTactics.html'>递归与分治策略</a>
                </li>
                <li>
                    <a href='DynamicPlan.html' class='select'>动态规划</a>
                </li>
                <li>
                    <a href='GreedyAlgorithm.html'>贪心算法</a>
                </li>
                <li>
                    <a href='Backtrack.html'>回溯法</a>
                </li>
                <li>
                    <a href='BranchLimit.html'>分支限界法</a>
                </li>
            </ul>
        </nav>
        <div id='content'>
            <article class='notebook content'>
                <section class='section'>
                    <p class="title-flag block">
                        基本思想
                    </p>
                    <p class="block">
                        和分治法基本思想有共同的地方，不同的是子问题往往不是独立的，有事母问题要借助子问题的解来判断，因此把已经计算好的问题记录在表格中，后续如果需要查询一下，可以避免重复计算，这是动态规划的基本思想。
                    </p>
                    <p class="block">
                        不过动态规划具体实现起来多种多样，不过都具有相同的填表格式，通常按照下面步骤设计算法：
                        <span class="list">1）找出最优解的性质，并刻画其结构特征；</span>
                        <span class="list">2）递归的定义最优值；</span>
                        <span class="list">3）以自底向上的方式计算出最优值；</span>
                        <span class="list">4）通过计算最优值时刻意记录的判断结果来构造最优解。</span>
                    </p>
                    <p class="block">
                        可以使用该算法思想设计算法的问题一般会具有二个决定性的性质：
                        <span class="list">1）最优子结构性质；</span>
                        <span class="list">2）子问题重叠性质。</span>
                    </p>
                </section>
                <section class='section'>
                    <p class="title-flag block">
                        备忘录算法
                    </p>
                    <p class="block">
                        和上面的算法思想差不多，不同的是备忘录为每个解过的子问题建立备忘录以备需要的时候查看，避免了相同的问题计算多次。
                    </p>
                    <p class="block">
                        一般来说，当一个问题的所有子问题都至少要解一次时，用动态规划比备忘录要好，因为不会有任务暂存且没有多余的计算；当子问题空间中部分问题不必解时，用备忘录比较好。
                    </p>
                    <p class="block">
                        不过上面不是绝对的，这样说只是想区别一下二个思想的不同，具体的时候还是要根据业务场景来在保证可行的前提下选择更好的方法。
                    </p>
                </section>
                <section class='section'>
                    <p class="title-flag block">
                        算法使用例子
                    </p>
                    <p class="block little-flag">
                        题目
                    </p>
                    <p class="block">
                        给定n个矩形{A1,A2,...,An},其中Ai与Ai+1是可乘的，由于矩阵满足结合律，不同的加括号方法计算次数不一样，求最优的加括号方法。
                    </p>
                    <p class="block little-flag">
                        思路
                    </p>
                    <p class="block">
                        分别计算有1，2，3，...，n个矩阵的最优解，计算i个时候，全部的i-1的最优解已经记录下来了，保证计算不重复。
                    </p>
                    <p class="block little-flag">
                        代码实现
                    </p>
                    <p class="block demo">
                        <span onclick='showCode("javaCode")'>Java代码</span>
                        <span onclick='showCode("pythonCode")'>Python代码</span>
                        <span onclick='showCode("javascriptCode")'>JavaScript代码</span>
                        <span onclick='showCode("cCode")'>C语言代码</span>
                        <pre id='javaCode' class='code'>import java.util.Arrays;

    public class MatrixMultiply{
        public static void main(String [] args){
            /**
             * 初始化数据
             */
            int []P = {30, 35, 15, 5, 10, 20, 25}; //记录了矩阵的大小
            int num = P.length - 1; //矩阵个数
            int [][]minNum =new int[num][num] ;
            int i, j; //全局复杂循环变量

            /**
             * 初始化数据
             */
            for (i = 0; i &lt; num; i++) {
                for (j = 0; j &lt; num; j++) {
                    if (i == j) {
                        minNum[i][j] = 0;
                    } else {
                        minNum[i][j] = -1;
                    }
                }
            }
            /**
             * 计算最优并记录下来
             */
            for(i=2;i&lt;=num;i++){//计算的矩阵个数，从二个开始到全部的情况
                for(j=1;j&lt;=num+1-i;j++){//计算矩阵第j到第i+j-1个的情况
                    //先初始化认为在第j分割是最优的（在第j分割的意思是j单独一个，j+1-&gt;i+j-1是一组）
                    int splitIndex=j;
                    int splitMin=minNum[j][i+j-2]+P[j-1]*P[j]*P[i+j-1];
                    minNum[j-1][i+j-2]=splitMin;
                    for(splitIndex=j+1;splitIndex&lt;=i+j-2;splitIndex++){
                        splitMin=minNum[j-1][splitIndex-1]+minNum[splitIndex][i+j-2]+P[j-1]*P[splitIndex]*P[i+j-1];
                        if(splitMin&lt;minNum[j-1][i+j-2]){
                            minNum[j-1][i+j-2]=splitMin;
                        }
                    }
                }
            }

            System.out.println("最优次数:");
            for(i=0;i&lt;num;i++){
                System.out.println(Arrays.toString(minNum[i]));
            }

        }
    }</pre>
                        <pre id='pythonCode' class='code default'>#!/usr/bin/python
    # coding=utf-8

    '''
     * 初始化数据
    '''
    P = [30, 35, 15, 5, 10, 20, 25]; #记录了矩阵的大小
    num = len(P) - 1; #矩阵个数
    minNum = [[0 for x in range(num)] for y in range(num)];

    '''
     * 初始化数据
    '''

    for i in range(0,num):
        for j in range(0,num):
            if (i == j) :
                minNum[i][j] = 0;
            else :
                minNum[i][j] = -1;
    '''
     * 计算最优并记录下来
    '''
    print "最优次数:",minNum;
    for i in range(2,num+1):
        for j in range(1,num+2-i):
            #先初始化认为在第j分割是最优的（在第j分割的意思是j单独一个，j+1-&gt;i+j-1是一组）
            splitIndex=j;
            splitMin=minNum[j][i+j-2]+P[j-1]*P[j]*P[i+j-1];
            minNum[j-1][i+j-2]=splitMin;
            splitIndex=j+1;
            for splitIndex in range(j,i+j-1):
                splitMin=minNum[j-1][splitIndex-1]+minNum[splitIndex][i+j-2]+P[j-1]*P[splitIndex]*P[i+j-1];
                if(splitMin&lt;minNum[j-1][i+j-2]):
                    minNum[j-1][i+j-2]=splitMin;

    print "最优次数:",minNum;</pre>
                        <pre id='javascriptCode' class='code default'>/**
    * 初始化数据
    */
    var P = [30, 35, 15, 5, 10, 20, 25]; //记录了矩阵的大小
    var num = P.length - 1; //矩阵个数
    var minNum = [];
    var i, j; //全局复杂循环变量

    /**
    * 初始化数据
    */
    for (i = 0; i &lt; num; i++) {
        minNum[i] = [];
        for (j = 0; j &lt; num; j++) {
            if (i == j) {
                minNum[i][j] = 0;
            } else {
                minNum[i][j] = "#";
            }
        }
    }
    /**
    * 计算最优并记录下来
    */
    for(i=2;i&lt;=num;i++){//计算的矩阵个数，从二个开始到全部的情况
        for(j=1;j&lt;=num+1-i;j++){//计算矩阵第j到第i+j-1个的情况
            //先初始化认为在第j分割是最优的（在第j分割的意思是j单独一个，j+1-&gt;i+j-1是一组）
            var splitIndex=j;
            var splitMin=minNum[j][i+j-2]+P[j-1]*P[j]*P[i+j-1];
            minNum[j-1][i+j-2]=splitMin;
            for(splitIndex=j+1;splitIndex&lt;=i+j-2;splitIndex++){
                splitMin=minNum[j-1][splitIndex-1]+minNum[splitIndex][i+j-2]+P[j-1]*P[splitIndex]*P[i+j-1];
                if(splitMin&lt;minNum[j-1][i+j-2]){
                    minNum[j-1][i+j-2]=splitMin;
                }
            }
        }
    }

    console.log("最优次数:");
    console.log(minNum);</pre>
                        <pre id='cCode' class='code default'>#include &lt;stdio.h&gt;
    int main()
    {
        /**
         * 初始化数据
         */
        int P[] = {30, 35, 15, 5, 10, 20, 25}; //记录了矩阵的大小
        int num = sizeof(P) / sizeof(int) - 1; //矩阵个数
        int minNum[num][num];
        int i, j; //全局复杂循环变量

        /**
         * 初始化数据
         */
        for (i = 0; i &lt; num; i++)
        {
            for (j = 0; j &lt; num; j++)
            {
                if (i == j)
                {
                    minNum[i][j] = 0;
                }
                else
                {
                    minNum[i][j] = -1;
                }
            }
        }
        /**
         * 计算最优并记录下来
         */
        for (i = 2; i &lt;= num; i++)
        {
            //计算的矩阵个数，从二个开始到全部的情况
            for (j = 1; j &lt;= num + 1 - i; j++)
            {
                //计算矩阵第j到第i+j-1个的情况
                //先初始化认为在第j分割是最优的（在第j分割的意思是j单独一个，j+1-&gt;i+j-1是一组）
                int splitIndex = j;
                int splitMin = minNum[j][i + j - 2] + P[j - 1] * P[j] * P[i + j - 1];
                minNum[j - 1][i + j - 2] = splitMin;
                for (splitIndex = j + 1; splitIndex &lt;= i + j - 2; splitIndex++)
                {
                    splitMin = minNum[j - 1][splitIndex - 1] + minNum[splitIndex][i + j - 2] + P[j - 1] * P[splitIndex] * P[i + j - 1];
                    if (splitMin &lt; minNum[j - 1][i + j - 2])
                    {
                        minNum[j - 1][i + j - 2] = splitMin;
                    }
                }
            }
        }

        printf("最优次数:\n");
        for (i = 0; i &lt; num; i++)
        {
            printf("[");
            for (j = 0; j &lt; num - 1; j++)
            {
                printf("%d,", minNum[i][j]);
            }
            printf("%d", minNum[i][num - 1]);
            printf("]\n");
        }
    }</pre>
                    </p>
                </section>
            </article>
            <style>
                .default {
                    display: none;
                }

                .block.demo span {
                    color: #f6f8f8;
                    background-color: #03A9F4;
                    padding: 5px;
                    border-radius: 5px;
                    cursor: pointer;
                }
            </style>
            <script>
                function showCode(id) {
                    document.getElementById('javaCode').style.display = 'none';
                    document.getElementById('pythonCode').style.display = 'none';
                    document.getElementById('javascriptCode').style.display = 'none';
                    document.getElementById('cCode').style.display = 'none';
                    document.getElementById(id).style.display = 'block';
                }
            </script>
    </section>
    <footer>
        <div>
            <div class='info'>
                yelloxing.github.io is sponsored by StepByStep | 本网站由【走一步 再走一步】支持
            </div>
            <div class='nav' onclick='window.location.href="https://github.com/yelloxing/yelloxing.github.io"'>
                Fork me on Github
            </div>
        </div>
    </footer>
</body>

</html>

<!--
=================================================
走一步，再走一步。
=================================================
-->
